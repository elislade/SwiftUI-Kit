import SwiftUI


public extension View {
    
    #if os(watchOS)
    
    func onKeyPressPolyfill(phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> Self {
        self
    }
    
    func onKeyPressPolyfill(_ key: KeyEquivalent, phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> Self {
        self
    }
    
    func onKeyPressPolyfill(keys: Set<KeyEquivalent>, phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> Self {
        self
    }
    
    func onKeyPressPolyfill(characters: CharacterSet, phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> Self {
        self
    }
    
    #else
    
    func onKeyPressPolyfill(
        phases: KeyPress.Phases = [.down, .repeat],
        action: @escaping (KeyPress) -> KeyPress.Result
    ) -> some View {
        modifier(KeyPressPolyfill(
            mask: nil,
            phases: phases,
            action: action
        ))
    }
    
    @inlinable func onKeyPressPolyfill(
        _ key: KeyEquivalent,
        phases: KeyPress.Phases = [.down, .repeat],
        action: @escaping (KeyPress) -> KeyPress.Result
    ) -> some View {
        onKeyPressPolyfill(keys: [key], phases: phases, action: action)
    }
    
    func onKeyPressPolyfill(
        keys: Set<KeyEquivalent>,
        phases: KeyPress.Phases = [.down, .repeat],
        action: @escaping  (KeyPress) -> KeyPress.Result
    ) -> some View {
        modifier(KeyPressPolyfill(
            mask: .equivalentSet(keys),
            phases: phases,
            action: action
        ))
    }
    
    func onKeyPressPolyfill(
        characters: CharacterSet,
        phases: KeyPress.Phases = [.down, .repeat],
        action: @escaping (KeyPress) -> KeyPress.Result
    ) -> some View {
        modifier(KeyPressPolyfill(
            mask: .charSet(characters),
            phases: phases,
            action: action
        ))
    }
    
    #endif
    
}




public struct KeyPress : Sendable {

    /// The phase of the key-press event (`.down`, `.repeat`, or `.up`).
    public let phase: KeyPress.Phases

    /// The key equivalent value for the pressed key.
    public let key: KeyEquivalent

    /// The characters generated by the pressed key as if no modifier
    /// key applies.
    public let characters: String

    /// The set of modifier keys the user held in addition to the
    /// pressed key.
    public let modifiers: EventModifiers
    
    
    public struct Phases : OptionSet, Sendable {

        /// The user pressed down on a key.
        public static let down: KeyPress.Phases = .init(rawValue: 1 << 0)

        /// The user held a key down to issue a sequence of repeating events.
        public static let `repeat`: KeyPress.Phases = .init(rawValue: 1 << 1)

        /// The user released a key.
        public static let up: KeyPress.Phases = .init(rawValue: 1 << 2)

        public static let all: KeyPress.Phases = .init(rawValue: .max)

        public let rawValue: Int

        public init(rawValue: Int){
            self.rawValue = rawValue
        }

    }
    
    public enum Result : Hashable, Sendable {

        /// The action consumed the event, preventing dispatch from continuing.
        case handled

        /// The action ignored the event, allowing dispatch to continue.
        case ignored
    }
    
}


extension KeyPress {
    
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
    init(_ press: SwiftUI.KeyPress) {
        self.key = press.key
        self.characters = press.characters
        self.modifiers = press.modifiers
        self.phase = .init(press.phase)
    }
    
}

extension KeyPress.Phases {
    
    @available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
    init(_ phases: SwiftUI.KeyPress.Phases){
        self.init(rawValue: phases.rawValue)
    }
    
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
extension SwiftUI.KeyPress.Phases {
    
    init(_ phases: KeyPress.Phases){
        self.init(rawValue: phases.rawValue)
    }
    
}


@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
extension SwiftUI.KeyPress.Result {
    
    init(_ result: KeyPress.Result) {
        switch result {
        case .handled: self = .handled
        case .ignored: self = .ignored
        }
    }
    
}


extension KeyEquivalent: @retroactive Hashable {

    public var hashValue: Int { character.hashValue }
    
    public func hash(into hasher: inout Hasher){
        character.hash(into: &hasher)
    }
    
}


extension KeyEquivalent: @retroactive Equatable {

    public static func == (lhs: KeyEquivalent, rhs: KeyEquivalent) -> Bool {
        lhs.character == rhs.character
    }
    
}
